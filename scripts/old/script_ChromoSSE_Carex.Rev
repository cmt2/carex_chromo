#########################
# Read in the data
#########################
seed(1)


# Read in the phylogeny. The phylogeny is pruned
phylogeny <- readTrees("data/phy3f_pruned.tree")[1]

# We need to limit the maximum number of chromosomes,
# so here we just use the largest chromosome count plus 10.
max_chromo = 72

# Get the chromosome counts from a tab-delimited file.
chromo_data = readCharacterDataDelimited("data/carex_chromosome_counts.tsv", stateLabels=(max_chromo + 1), type="NaturalNumbers", delimiter="\t", headers=FALSE)


#########################
# Chromosome Model
#########################

#
# Anagenetic changes:
#

# We'll use exponential priors to model the rates of polyploidy and
# dysploidy events along the branches of the phylogeny

# rate of chromosome gains
gamma ~ dnExponential(0.5) #Increase by one

# rate of chromosome losses
delta ~ dnExponential(.5) #Deacrease by one

# rate of polyploidization
rho <- 0
# rate of demi-polyploidization
eta <- 0

# Add MCMC moves for each of the rates.
mvi = 1
moves[mvi++] = mvScale(gamma, lambda=1, weight=1)
moves[mvi++] = mvScale(delta, lambda=1, weight=1)


# Now we create the rate matrix for the chromosome evolution model.
# Here we will use a ChromEvol model that includes
# the rate of chromosome gain, loss, polyploidization and demi-polyploidization.
Q := fnChromosomes(max_chromo, gamma, delta, rho, eta)

print("finished setting up anagenetic changes")
#
# Cladogenetic changes:
#

# expected num species at time t under constant birth-death is
# # E(N_t) = N_0 e^{rt}
# # therefore net diversification r is
# # r = ( ln N_t - ln N_0 ) / t
# # we use r as the mean for the speciation prior
taxa <- phylogeny.taxa()
speciation_mean <- ln( taxa.size() ) / phylogeny.rootAge()
speciation_pr <- 1 / speciation_mean

# Each cladogenetic event type is assigned its own speciation rate.
clado_no_change ~ dnExponential(speciation_pr)
clado_fission ~ dnExponential(speciation_pr)
clado_fusion ~ dnExponential(speciation_pr)
clado_polyploid <- 0
clado_demipoly <- 0
# MCMC moves for speciation rates
moves[mvi++] = mvScale(clado_no_change, lambda=5.0, weight=1)
moves[mvi++] = mvScale(clado_fission, lambda=5.0, weight=1)
moves[mvi++] = mvScale(clado_fusion, lambda=5.0, weight=1)


# set a vector to hold the speciation rates
spec_rates := [clado_no_change, clado_fission, clado_fusion, clado_polyploid, clado_demipoly]
total_speciation := sum(spec_rates)

# map the speciation rates to chromosome cladogenetic events
clado_matrix := fnChromosomesCladoEventsBD(speciation_rates = spec_rates, max_chromosomes = max_chromo)

# a stochastic variable to represent the turnover.
turnover ~ dnUniform(0, 1.0)
turnover.setValue(0.4)
moves[mvi++] = mvScale(turnover, lambda=5.0, weight=3.0)

# Make a vector of extinction rates for each state.
# In the basic ChromoSSE model we assume all chromosome
# numbers have the same extinction rate.
for (i in 1:(max_chromo + 1)) {
    extinction[i] := turnover * total_speciation
}
print("finished setting up cladogenetic changes")
# Here we assume the frequency of chromosome numbers at the root of the tree
# are equal. In future examples we will instead treat the root frequencies
# as a free variable and estimate them from the observed data.
root_freqs := simplex(rep(1, max_chromo + 1))
# the below code seems to work, but causes a seg fault when calculating
# the log likelihood of chromo_bdp. When I used 0 instead of 0.001, the
# mymodel throws an error "Error:	Cannot compute log-gamma function for x = 0"
# k = 0
# for(i in 1:9) {
#   prior_rf[++k] <- 0.001
# }
# for(i in 1:50) {
#   prior_rf[++k] <- 1
# }
# for(i in 1:72) {
#   prior_rf[++k] <- 0.001
# }
# rate_category_prior ~ dnDirichlet( prior_rf )
# moves[mvi++] = mvBetaSimplex(rate_category_prior,tune=true,weight=2)

# Here we set the probability of sampling species at the present.
rho_bd <- 0.4

# Construct a variable for the tree and chromosomes drawn from a
# cladogenetic character state dependent birth death process
chromo_bdp ~ dnCDCladoBDP( rootAge            = phylogeny.rootAge(),
                    cladoEventMap             = clado_matrix,
                    extinctionRates           = extinction,
                    Q                         = Q,
                    delta                     = 1.0,
                    pi                        = root_freqs,
                    rho                       = rho_bd,
                    condition                 = "time")
print("finished drawing from CDCCladoBDP")

# chromo_bdp.lnProbability()
# and clamp the observed tree and the chromosome count data
chromo_bdp.clamp(phylogeny)
print("finished clamping tree")
# chromo_bdp.lnProbability()

chromo_bdp.clampCharData(chromo_data)
print("finished clamping data")
chromo_bdp.lnProbability()

# Finally we wrap our model into a single model object.
mymodel = model(phylogeny)
print("finished setting up model object")

#########################
# MCMC
#########################


# Create the MCMC monitors:
# First, a screen monitor with some useful variables:
monitors[1] = mnScreen(printgen=10)

# The ancestral state monitor for sampling ancestral states:
#monitors[2] = mnJointConditionalAncestralState(filename="output/ChromoSSE_anc_states.log", printgen=1, tree=phylogeny, cdbdp=chromo_bdp, withStartStates=true, type="NaturalNumbers")

# And another monitor for all the model variables:
# monitors[3] = mnModel(filename="output/ChromoSSE_model.log", printgen=1)
monitors[2] = mnModel(filename="output/ChromoSSE_model.log", printgen=1)

# Now set up the MCMC.
mymcmc = mcmc(mymodel, monitors, moves, nruns=1, combine="mixed")
print("set up MCMC")

# Run the MCMC. Note that for a real analysis you'd want to run many more
# iterations and check for convergence.
# mymcmc.burnin(generations=100,tuningInterval=10)
mymcmc.run(5000)


#########################
# Summarize the results
#########################


# Now let's summarize the sampled ancestral chromosome numbers.
# First, read in the ancestral state trace:
#anc_state_trace = readAncestralStateTrace("output/ChromoSSE_anc_states.log")

# Finally, summarize the values from the traces over the phylogeny.

#ancestralStateTree(phylogeny, anc_state_trace, "output/ChromoSSE_final.tree", include_start_states=true, reconstruction="marginal")
